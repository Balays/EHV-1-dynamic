---
title: "EHV-1 TSS dynamics"
author: Bal√°zs Kakuk
output: 
  html_document:
    theme: cosmo
    toc: yes
    toc_float:
      collapsed: false
---

```{css, echo=FALSE}
    body .main-container {
      max-width: 90% !important;
      width: 90% !important;
    }
    body {
      max-width: 90% !important;
      margin-left: auto;
      margin-right: auto;
    }
```


```{r include=FALSE}
## hrbrthemes::ipsum:

knitr::opts_chunk$set(fig.retina=2, echo = FALSE, fig.align = 'center', message = F, warning = F)
```

```{r ipsum_setup, message=FALSE, warning=FALSE, cache=FALSE, echo=FALSE}
library(prettydoc)
library(hrbrthemes, quietly = T)
#library(GenomicFeatures, quietly = T)
library(DESeq2, quietly = T)
library(ggpubr, quietly = T)
#library(misc, quietly = T)
library(dplyr, quietly = T)
#library(tidyverse, quietly = T)
library(ggsci, quietly = T)
#library(Gviz, quietly = T)
library(dplyr, quietly = T)
library(tidyr)
library(scales)
#library(plyr)
library(moanin, quietly = T)
library(grid, quietly = T)
library(gridExtra, quietly = T) 
library(ggpubr, quietly = T)
library(data.table)
library(ggh4x)
library(knitr)
library(formattable)


###
source('_WF.part0.R')

#### Settings ####

## Main
#save.data <- 'PRV.rebase.RData'
EndType <- 'TSS'

project_config  <- fread('project_config.txt')
outdir  <- project_config$outdir
res.dir <- outdir; try({ dir.create(res.dir) })
fig.dir <- paste0(res.dir, '/', EndType, '_abund'); # try({ dir.create(fig.dir) })## save plots to this directory

## Miscallenaous
palette <- pal_npg()(10)

writetables <- T



```


# Project info
Samples: dcDNA Seq  
pychopper: no  
mapping version: v6  
LoRTIA: yes (stranded only output)  


## Normalization: Viral read count


# TSS dynamics 

## Those reads were counted only, where the *5-prime* adapters were "correct" (according to LoRTIA)



```{r, message=FALSE, warning=FALSE, cache=FALSE, echo=FALSE, eval=T}
#### Import counts

gene.sample_count.sp <- fread(paste0(res.dir, '/gene.sample.count.sp.tsv'), na.strings = '')


#### !!! Consider adapters!
adapters <- 'prime5'

source('Gene.counts.R')

#gene.sample_count    <- TR.ref.sum[,.(count=sum(read_count)), by=.(seqnames, strand, gene_cluster, gene, Kinetic_class, sample)]
#gene.sample_count.sp <- dcast(gene.sample_count, seqnames + strand + gene_cluster + gene + Kinetic_class ~ sample)
####

orf.sum <- gene.sample_count.sp

## Filter out multi-copied genes
orf.sum <- orf.sum[!gene %in% c('ORF64_2', 'ORF65_2', 'ORF66_2', 'ORF67_2'),]
orf.sum <- orf.sum[!gene_cluster %in% c('ORF64_2', 'ORF65_2', 'ORF66_2', 'ORF67_2'),]

## Format columns
#orf.sum <- orf.sum[,!c("seqnames", "gene_cluster"), with = FALSE]
#setnames(orf.sum, old=c('Kinetic_class'), new=c('ID'))
orf.sum[,ID := gene]

# Reordering columns to make new_column the first column
setcolorder(orf.sum, c("ID", setdiff(names(orf.sum), "ID")))

## Factorize
orf.sum$gene          <- factor(orf.sum$gene,  levels=ORFs)
orf.sum$ID            <- factor(orf.sum$ID,    levels=ORFs)
orf.sum$Kinetic_class <- factor(orf.sum$Kinetic_class, levels=c('IE', 'E', 'L'))

## Order
orf.sum        <- orf.sum[order(Kinetic_class, gene),]

##
orf.counts     <- as.data.frame(orf.sum)

orf.sum        <- merge(gather(orf.sum, sample, read_count, -c(1:6)), metafilt[,metacols], by='sample')
setDT(orf.sum)



#### Normalization method
norm.method <- 'viral_read.count'
#multip      <- 10000

 if (norm.method == 'average_genome') {
  
  ## Average genome norm method
  norm_cov_summary <- fread(paste0(outdir, '/norm.cov.summary.tsv'), na.strings = '')
  normBase <- norm_cov_summary[,.(sample, average_coverage)]
  colnames(normBase)[2] <- 'norm_base'
  
  fig.dir <- paste0(fig.dir, '.norm_genome')

} else if (norm.method == 'viral_read.count') {
    
  ## Viral read count method
  # sum up all the ORF counts

  #normBase <- melt(gene.sample_count.sp, variable.name = 'sample', value.name = 'count')
  #normBase <- normBase[,.(norm_base = sum(count)), by=sample]
  normBase <- orf.sum[,.(norm_base = sum(read_count)), by=sample]
  
  fig.dir <- paste0(fig.dir, '.norm_LoRTIA')
  
} else if (norm.method == 'total_read.count') {
  ## For total read count method

  # This is not the LoRTIA-processed read counts, so each read is counted twice because they are from dcDNA that contains both orientations. 
  # But since this is true for both the virus and the host, this will cause each ORF to be estimated down approx 2-fold but in an unbiased way.

  normBase <- fread('../fastq_read_counts.tsv')
  #normBase[ , sample := gsub('.fastq', '', file)]
  normBase[ , norm_base := read_count]
  normBase <- normBase[,.(sample, norm_base)]
  
  fig.dir <- paste0(fig.dir, '.norm_total')
  
} else if (norm.method == 'host_read.count') {
  ## For total HOST read count method

  # This is not the LoRTIA-processed read counts, so each read is counted twice because they are from dcDNA that contains both orientations. 
  # But since this is true for both the virus and the host, this will cause each ORF to be estimated down approx 2-fold but in an unbiased way.
  # Currently this is the unmapped read count!

  viral_reads <- melt(gene.sample_count.sp, variable.name = 'sample', value.name = 'count')
  viral_reads <- viral_reads[,.(viral_read_count = sum(count)), by=sample]
  
  total_reads <- fread('../fastq_read_counts.tsv')
  
  normBase    <- merge(total_reads, viral_reads, by='sample')
  normBase[,norm_base := read_count - viral_read_count]
  
  normBase <- normBase[,.(sample, norm_base)]
   
  fig.dir <- paste0(fig.dir, '.norm_host')
  
} else if (norm.method == 'WO') {
  
  ## NO normalization of counts

  normBase <- data.table(sample = metafilt$sample, norm_base = 1)
  
  fig.dir <- paste0(fig.dir, '.norm_Without')
  
} else if (norm.method == 'VST') {
    
  ## DESeqs VSTViral read count method

  normBase <- data.table(sample = metafilt$sample, norm_base = 1)
  
  fig.dir <- paste0(fig.dir, '.norm_VST')
  
} 

##
normBase <- normBase[order(normBase$sample, colnames(orf.counts[-c(1:6)])), ]
stopifnot(all(normBase$sample == colnames(orf.counts[-c(1:6)]) ))

orf.perc <- merge(normBase, orf.sum, by='sample')
orf.perc[,read_count := read_count / norm_base]



try({ dir.create(fig.dir) })

#### TO-DO: 

## 1.) find which replicate is the farthest from the mean in each gene for each group -> done
## 2.) Carry out the moanin analyis using the current normalization 
## 3.) Check the overlap of Literature-based kinetic classes and de-novo clusters
```


```{r}
### Filtering of very-low coverage samples
samples_to_filt <- NULL #c('C6_2h_3', 'PC-12_8h_3')

if (!is.null(samples_to_filt)) {
  
  orf.perc <- orf.perc[!orf.perc$sample %in% samples_to_filt, ]
  metafilt <- metafilt[!metafilt$sample %in% samples_to_filt, ]
  
  message(paste(samples_to_filt, ' was filtered out!', collapse = '\n') )

}
```


## Statistics of counts {.tabset}
```{r, message=FALSE, warning=FALSE, cache=FALSE, echo=FALSE}
orf.sum.perc <- orf.perc

if (EndType == 'TES') {
  
  #### Keep those where the TES was correct, regardless of TSS
  message('Keeping those where the TES was correct, regardless of TSS !')
  orf.sum.perc[,gene   := gene_cluster]
  orf.sum.perc <- orf.sum.perc[!is.na(gene), ]
  
} else if (EndType == 'TSS') {
  
  #### Keep those where the TSS was correct, regardless of TES
  message('Keeping those where the TSS was correct, regardless of TES !')
  orf.sum.perc[,gene_cluster   := gene]
  orf.sum.perc <- orf.sum.perc[!is.na(gene), ]
  
} else if (EndType == 'TSS.TES') {
  
  #### Keep those where noth the TSS and TES were correct
  message('Keeping those where noth the TSS and TES were correct !')
  orf.sum.perc[,gene_cluster   := gene]
  orf.sum.perc <- orf.sum.perc[!is.na(gene), ]
}

gene_kin.class <- na.omit(unique(orf.sum.perc[,.(gene, Kinetic_class)]))
gene_kin.class[,Kinetic_class := paste(Kinetic_class, collapse = '/'), by=.(gene)]
gene_kin.class <- unique(gene_kin.class[,.(gene, Kinetic_class)])

orf.sum.perc[,Kinetic_class := NULL]

#### Summarize the counts

## summarise counts on gene cluster
orf.sum.perc <- orf.sum.perc[,.(read_count=sum(read_count)), by=.(seqnames, strand, gene, norm_base, sample, group, hpi, Time, cell_line)]
orf.sum.perc <- merge(orf.sum.perc, gene_kin.class, by='gene', all=T)
orf.sum.perc[is.na(Kinetic_class), Kinetic_class := 'unknown']
orf.sum.perc[,Kinetic_class := factor(Kinetic_class, levels = c('IE', 'IE/E', 'E', 'IE/E/L', 'E/L', 'L', 'unknown'))]
```

```{r}



orf.sum.sp     <- dcast.data.table(orf.sum.perc, gene~sample, value.var = 'read_count')

orf.sum.sp.mat <- as.matrix(data.frame(orf.sum.sp[,-1], row.names = orf.sum.sp$gene))
colnames(orf.sum.sp.mat) <- gsub('\\.', '-', colnames(orf.sum.sp.mat))

colData = data.frame(metafilt, row.names = metafilt$sample)

orf.sum.sp.mat <- orf.sum.sp.mat[,rownames(colData)]
  

if (norm.method == 'VST') {  
  deseq <- DESeqDataSetFromMatrix(orf.sum.sp.mat, colData = colData, ~ hpi)
  deseq <- estimateSizeFactors(deseq, type =  "poscounts")
  deseq <- DESeq(deseq)
  results(deseq)
  
  vsd      <- varianceStabilizingTransformation(deseq)
  vsd_mat  <- assay(vsd)[,metafilt$sample]
  vsd_data <- data.table(gene = rownames(vsd_mat), vsd_mat)

  vsd_melt <- melt.data.table(vsd_data, 
      id.vars = 'gene',
      value.name = 'norm_read_count', 
      variable.name = 'sample')
  #vsd_melt <- merge(vsd_melt, metafilt, by='sample')

  orf.sum.percx <- merge(orf.sum.perc, 
                        vsd_melt,
                        by=c('gene', 'sample'))
  if(nrow(orf.sum.percx) == nrow(orf.sum.perc)) {
    orf.sum.perc <- orf.sum.percx
    rm(orf.sum.percx)
  } else { stop() }
  
  orf.sum.sp.mat <- vsd_mat
  
}
```

```{r, message=FALSE, warning=FALSE, cache=FALSE, echo=FALSE}
### Statistics of gene cluster counts accross samples

## normalized counts
orf.perc.mean <- 
  orf.sum.perc[,.(mean=mean(read_count), sd=sd(read_count), varcoeff=sd(read_count) / mean(read_count)), 
               by=.(gene, Kinetic_class, hpi, Time, cell_line)]


#### merge back summary with counts
orf.sum.perc <- merge(orf.sum.perc, orf.perc.mean, by=c('gene', 'Kinetic_class', 'hpi', 'Time', 'cell_line'))


```

### Difference from mean
```{r, fig.width = 9, fig.height = 6, eval=T}

#### Find which replicate is the farthest from the mean in each gene for each group

# find distance from mean
orf.sum.perc[ , dist_from_mean := abs(mean - read_count)]

##
orf.sum.perc[ , farthest_from_mean := fifelse(dist_from_mean == max(dist_from_mean), T, F), by=.(group, gene)]
# NA, if all is true in each group beacuse then the distance is the same which means probably that the gene has zero counts in that group
orf.sum.perc[ , farthest_from_mean := if(sum(dist_from_mean) == 0) NA, by=.(group, gene)]
orf.sum.perc[ , farthest_rep       := fifelse(!is.na(farthest_from_mean) & farthest_from_mean == T, gsub('.*_', '', sample), 'NA'), by=.(sample, gene)]

plot.data  <- orf.sum.perc[!is.na(farthest_rep), .N, by=.(farthest_rep, hpi, Time, cell_line, group)][order(group)]

ggplot(
  plot.data,
  aes(x=hpi, y=N, fill=farthest_rep)) +
  geom_col(position = 'dodge2') +
  scale_fill_d3() +
  theme_bw() # + facet_grid(rows=vars(hpi))

```


### Varcoeff
```{r, fig.width = 20, fig.height = 8}

ggplot(
  orf.sum.perc[],
  aes(x=gene, y=varcoeff, fill=hpi)) +
  geom_col(position = 'dodge2') +
  scale_fill_d3() +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90)) +
  facet_grid(rows=vars(cell_line))


```


## hclust
```{r, fig.width=16, fig.height=10}


countData <- orf.sum.sp.mat#[,metafilt$sample]

source('hcluster.R')


source('hclust.wss.R')

#cluster_dt[order(cluster)]
```





### Assigning genes to clusters
```{r}


### WRITE OUT DEG analyis and clustering RESULTS

DE_cluster_results <- cluster_dt[,.(ORF = gene, best_label=cluster, labels=cluster)]
#DE_cluster_results <- merge(DE_results, cluster_labels, by='ORF')
#stopifnot(nrow(DE_cluster_results) == nrow(DE_results))


```


```{r, eval=FALSE}
par(mfrow=c(3, 3))
n_clusters <- dim(kmeans_clusters$centroids)[1]
for(cluster_id in 1:n_clusters){
    hist(cluster_labels[best_label==cluster_id, 'score'],
     #breaks=(1:50/50), 
     xlim=c(0, 1),
     col="black", main=paste("C", cluster_id, sep=""),
     xlab="score", ylab="Num. genes")
    abline(v=scores_and_labels$score_cutoff, col="red", lwd=3, lty=2)
}


```



## ORF kinetics, according to literature-based kinetic classes {.tabset}


```{r}
### ORFs in samples calculated from TRS-B transcripts with and without leaders

max_ncol   <- 9
row_multip <- 6
col_multip <- 4
my_pal <- pal_d3()(10)


plotfun <- function(DT, 
                    geom1 = geom_pointrange(aes(ymin = mean-sd, ymax = mean+sd), colour = 'black'),
                    geom2 = geom_line(aes(x=Time, y=mean), color=kincolor),
                    geom3 = geom_point(aes(x=Time, y = mean), fill=kincolor, shape = 21, size = 3, colour = 'black'),
                    ncol = 10, title = NULL, #"Normalized ORF counts", 
                    strip.backgr = pal_d3()(10)[2],
                    kincolor=NULL) {
  
  if (nrow(DT) == 0) { 
    ggp <- NULL } else {   # try({ 
      
    # 
    gene_N <- length(unique(DT[,gene]))
    # class_freq <- DT[best_label == 5][,.N,by=class_col]
    
    #colid <- c('gene', class_col)
    #class_freq <- unique(DT[best_label == 5, ..colid])
    
    
    #  min(class_freq)
     # =='adaptive') {}
        
    ggp <- 
      ggplot(DT[
                                #  orf.perc.mean$hpi    != 'dRNA' 
                                #& orf.perc.mean$strand == '+'
                                , ], 
                     aes(Time, mean, color = 'cell_line')
                     #, add = 'loess'
                     ) + 
      geom1 +
      geom2 + 
      geom3 +
      scale_color_manual(values = palette) +
      scale_y_continuous(labels = scales::percent_format(), name = 'Mean abundance %') +
      scale_x_continuous(name = 'Hours past infection') +
      theme_ipsum() +
      theme(plot.margin = unit(c(1,1,1,1), 'mm')) +
      facet_wrap(~ gene, scales = 'free_y', ncol = ncol) +
      theme(strip.background = element_rect(fill = alpha(strip.backgr, 0.4))
            )
      # + ggtitle(title)
  
  if (gene_N < ncol) { 
    if(gene_N == 1) { gene_N <- 1.5}
    ggp <- cowplot::plot_grid(ggp, NULL, rel_widths = c(gene_N, ncol - gene_N ), nrow=1)
  }
  
  }   # })
  
  return(ggp)

}


## Barplot 
plotfun_all <- function(DT, 
                        geom_1 = geom_col(aes(x=gene, y=mean, fill=Kinetic_class), alpha=0.7, color='black'),
                        geom_2 = geom_errorbar(aes(x=gene, ymin = mean-sd, ymax=mean+sd)),
                        coord_c=coord_cartesian(ylim = c(0, 0.6)),
                        scale  = NULL, #scale_y_continuous(),
                        scfill = scale_fill_manual(values = palette),
                        cflip  = coord_flip(),
                        theme_g = theme_bw(),
                        facet   = facet_nested(rows=vars(Kinetic_class), cols = vars(hpi), scales = 'free_y'),
                        strip.backgr = pal_d3()(10)[2],
                        ncol = 10,
                        ...) {
  
  gene_N <- length(unique(DT[,gene]))
  
  ggp <- 
    ggplot(DT) +
    geom_1   +
    geom_2   +
    coord_c  +
    scale    +
    scfill   +
    cflip    +
    theme_g  +
    theme(strip.background = element_rect(fill = alpha(strip.backgr, 0.4)), ...) +
    facet
  
  if (gene_N < ncol) { 
    if(gene_N == 1) { gene_N <- 1.5}
    ggp <- cowplot::plot_grid(ggp, NULL, rel_widths = c(gene_N, ncol - gene_N ), nrow=1)
  }
  
  return(ggp)

}

#DT=orf.perc.mean
```



```{r}
# Kinetic class frequency

kin_classes      <- unique(orf.perc.mean[,.(gene, Kinetic_class)])
all.class.freq   <- data.table(kin_classes)[,.N, by=.(Kinetic_class) ][order(Kinetic_class)]

ncol     <- ifelse(max(all.class.freq$N) < max_ncol, max(all.class.freq$N), max_ncol)
relh     <- ceiling(all.class.freq$N / ncol)  #c(6,1,1,1,2)

```


```{r}
## Barplots

mapfun <- function(i, DT, all.class.freq, palette = my_pal, ...) {
  kin_class <- all.class.freq[i, Kinetic_class]
  strip.background <- palette[i]
  plotfun_all(DT[Kinetic_class == kin_class],  strip.backgr = strip.background, ...)
}

figh     <- length(unique(orf.perc.mean[,gene])) * 0.35
figw     <- figh

```


### Barplot of mean and SD
```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}
ggp <- plotfun_all(orf.perc.mean)

ggsave(paste0(fig.dir, '/', EndType, '_', norm.method,  '_Literature.Clusters', '_barplot.jpg'), ggp, width = figw, height = figh, limitsize = F)

ggp
```


```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}
ggp <- purrr::map(seq_along(relh), mapfun, orf.perc.mean, all.class.freq, ncol=ncol, legend.position='none')

ggp <- cowplot::plot_grid(plotlist = ggp, ncol = 1, rel_heights = relh, align = 'vh', axis=c('tblr'))

ggsave(paste0(fig.dir, '/', EndType, '_', norm.method,  '_Literature.Clusters', '_barplot2.jpg'), ggp, width = figw, height = figh, limitsize = F)

ggp

```



```{r}
## Scatter and line plots

mapfun <- function(i, DT, all.class.freq, palette = my_pal, ...) {
  kin_class <- all.class.freq[i, Kinetic_class]
  strip.background <- palette[i]
  plotfun(DT[Kinetic_class == kin_class],  
          strip.backgr = strip.background, 
          kincolor=strip.background,
          ...)
}


figw     <- ncol * col_multip
figh     <- nrow(all.class.freq) * row_multip

```


### Figure 5 REVIEW - Mean and SD with linear connection
```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}

ggp <- purrr::map(seq_along(relh), mapfun, orf.perc.mean, all.class.freq, ncol=ncol)

ggp <- cowplot::plot_grid(plotlist = ggp, ncol = 1, rel_heights = relh, align = 'v', axis=c('tblr'))


ggsave('Figures/Figure 4_REVIEW.jpg',  ggp, width = figw*0.8, height = figh, limitsize = F)

ggp
```


### Mean and SD with loess function
```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}
ggp <- purrr::map(seq_along(relh), mapfun, orf.perc.mean, all.class.freq, ncol=ncol)

ggp <- cowplot::plot_grid(plotlist = ggp, ncol = 1, rel_heights = relh, align = 'v', axis=c('tblr'))

ggsave(paste0(fig.dir, '/', EndType, '_', norm.method,  '_Literature.Clusters', '_mean.sd.loess.jpg'), ggp, width = figw, height = figh, limitsize = F)

ggp
```


### Mean and SD with linear connection - Figure 4
```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}

ggp <- purrr::map(seq_along(relh), mapfun, orf.perc.mean, all.class.freq, ncol=ncol, 
                  geom1 = geom_pointrange(aes(ymin = mean-sd, ymax = mean+sd, colour = cell_line)),
                  geom2 = geom_line(aes(x=Time, y=mean, color=cell_line)))

ggp <- cowplot::plot_grid(plotlist = ggp, ncol = 1, rel_heights = relh, align = 'v', axis=c('tblr'))


ggsave(paste0(fig.dir, '/', EndType, '_', norm.method, '_Literature.Clusters', '_mean.sd.linear.jpg'), ggp, width = figw, height = figh, limitsize = F)

ggsave('./Figures/Figure 4.jpg',       ggp, width = figw*0.8, height = figh,   limitsize = F)
ggsave('./Figures/Figure 4.small.jpg', ggp, width = figw*0.6, height = figh,   limitsize = F)

ggp
```

### Each replicate with loess
```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}

ggp <- purrr::map(seq_along(relh), mapfun, orf.sum.perc, all.class.freq, ncol=ncol, 
                  geom1 = geom_point( aes(x=Time, y=read_count, color=cell_line)),
                  geom2 = geom_smooth(aes(x=Time, y=read_count, color=cell_line)) )

ggp <- cowplot::plot_grid(plotlist = ggp, ncol = 1, rel_heights = relh, align = 'v', axis=c('tblr'))


ggsave(paste0(fig.dir, '/', EndType, '_', norm.method, '_Literature.Clusters', '_replicates.loess.jpg'), ggp, width = figw, height = figh, limitsize = F)

ggp
```


## ORF kinetics, according to de-novo kinetic classes {.tabset}


```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}

my_pal <- pal_jco()(10)[c(2,3,4,5,7)]

#DE_cluster_results <- fread(paste0(outdir, '/', 'moanin_DE_results.tsv'))
setDT(DE_cluster_results)
DEGs               <- unique(DE_cluster_results$ORF[DE_cluster_results$sig == T])

## Add cluster info
orf.perc.mean <- merge(orf.perc.mean, unique(DE_cluster_results[,.(ORF, best_label, labels)]), by.x='gene', by.y='ORF', all.x=T)
orf.sum.perc  <- merge(orf.sum.perc,  unique(DE_cluster_results[,.(ORF, best_label, labels)]), by.x='gene', by.y='ORF', all.x=T)

# LAbels frequency
all.label.freq    <- data.table(DE_cluster_results)[,.N, by=.(best_label) ][order(best_label)]
sig.label.freq    <- na.omit(data.table(DE_cluster_results)[,.N, by=.(labels) ][order(labels)])


```


### All ORFs - Mean and SD with linear connection


```{r}
## Scatter and line plots
ncol     <- ifelse(max(all.label.freq$N) < max_ncol, max(all.label.freq$N), max_ncol)
relh     <- ceiling(all.label.freq$N / ncol)  #c(6,1,1,1,2)

mapfun <- function(i, DT, label.freq, palette = my_pal, ...) {
  kin_class <- label.freq[i, best_label]
  strip.background <- palette[i]
  plotfun(DT[best_label == kin_class],  
          strip.backgr = strip.background, 
          kincolor=strip.background,
          ...)
}


figw     <- ncol * col_multip
figh     <- nrow(all.label.freq) * row_multip

```


### Figure 5 REVIEW - Mean and SD with linear connection
```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}

ggp <- purrr::map(seq_along(relh), mapfun, orf.perc.mean, all.label.freq, ncol=ncol)

ggp <- cowplot::plot_grid(plotlist = ggp, ncol = 1, rel_heights = relh, align = 'v', axis=c('tblr'))


ggsave('Figures/Figure 5_REVIEW.jpg',  ggp, width = figw*0.8, height = figh, limitsize = F)

ggp
```




### Clustered ORFs only - Mean and SD with linear connection

```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}
#
#IE.ratio <- 0.43
ncol     <- ifelse(max(sig.label.freq$N) < max_ncol, max(sig.label.freq$N), max_ncol)
relh     <- ceiling(sig.label.freq$N / ncol)  #c(6,1,1,1,2)
figw     <- ncol * col_multip
figh     <- nrow(sig.label.freq) * row_multip


mapfun <- function(i, DT, label.freq, palette = my_pal, ...) {
  label <- label.freq[i, labels]
  strip.background <- palette[i]
  plotfun(DT[best_label == label & !is.na(labels)],  strip.backgr = strip.background, ...)
}


ggp <- purrr::map(seq_along(relh), mapfun, orf.perc.mean, sig.label.freq, ncol=ncol, 
                  geom1 = geom_pointrange(aes(ymin = mean-sd, ymax = mean+sd, colour = cell_line)),
                  geom2 = geom_line(aes(x=Time, y=mean, color=cell_line)),
                  geom3=NULL)

ggp <- cowplot::plot_grid(plotlist = ggp, ncol = 1, rel_heights = relh, align = 'v', axis=c('tblr'))



ggsave(paste0(fig.dir, '/',  EndType, '_', norm.method, '_DeNovo.Sig.Clusters', '_mean.sd.linear.jpg'), ggp, width = figw, height = figh, limitsize = F)
```

```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}
ggp
```




## Compare literature and de novo kinetic classes

*NA shows the number of genes where the clustering did not yield an unambiguous result.*
  
```{r, fig.show='hold',  fig.width = 15, fig.height = 6, eval=T}
setDT(orf.perc.mean)
gene.kin.and.clusters <- unique(orf.perc.mean[ , .(gene, Kinetic_class, best_label, labels)])
class.dt              <- gene.kin.and.clusters[, .N, by=.(Kinetic_class, best_label, labels)]



ggplot(class.dt,
       aes(x=Kinetic_class, y=N, fill=as.factor(best_label))) +
  geom_col(position = 'dodge') +
  scale_fill_manual(values = palette) +
  #scale_y_continuous(labels = scales::percent_format()) +
  theme_ipsum() +
  facet_wrap(~labels, nrow = 1)


ggplot(class.dt,
       aes(x=as.factor(best_label), y=N, fill=Kinetic_class)) +
  geom_col(position = 'stack') +
  scale_fill_manual(values = palette) +
  #scale_y_continuous(labels = scales::percent_format()) +
  theme_ipsum() +
  facet_nested_wrap(~labels, nrow = 1)


```

## Combine Kinetic classes

```{r}
### Summarise based on literature kinetic class
kin.class.sum  <- orf.sum.perc[,.(sum_read_count=sum(read_count), mean_read_count=mean(read_count), sd_read_count=sd(read_count)), 
                              by=.(Kinetic_class, hpi, Time, cell_line, seqnames, norm_base, sample, group)]


### Summarise based on SIGNIFICANT de-novo kinetic cluster
sig.cluster.sum <- orf.sum.perc[,.(sum_read_count=sum(read_count), mean_read_count=mean(read_count), sd_read_count=sd(read_count)), 
                              by=.(labels, hpi, Time, cell_line, seqnames, norm_base, sample, group)]


### Summarise based on all de-novo kinetic cluster
all.cluster.sum <- orf.sum.perc[,.(sum_read_count=sum(read_count), mean_read_count=mean(read_count), sd_read_count=sd(read_count)), 
                              by=.(best_label, hpi, Time, cell_line, seqnames, norm_base, sample, group)]


```

```{r}
figw <- 13
figh <- 6
ncol <- 10

DT     <- orf.sum.perc
DT[,rep      := gsub('.*h_', '', sample)]
DT[,rep_gene := paste0(gene, '::', rep)]

```



### De Novo - Significant
```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}
ggp <- 
      ggplot(sig.cluster.sum[],
             aes(Time, mean_read_count, color = as.factor(labels))
                     #, add = 'loess'
                     ) + 
      geom_point() +
      geom_smooth() + 
      scale_color_manual(values = palette[]) +
      guides(color=guide_legend("de-novo cluster")) +
      #scale_y_continuous(labels = scales::percent_format()) +
      scale_x_continuous(breaks = c(1,2,4,6,8,12,24,48)) +
      theme_ipsum() +
      theme(plot.margin = unit(c(10,1,1,1), 'mm'),
            legend.position = 'bottom') +
      #theme(strip.background.y = element_rect(fill = alpha(strip.backgr, 0.4))) +
      # theme(strip.text.y = element_blank()) +
      #ggtitle(title) +
      facet_nested_wrap(~labels, nrow = 2, scales = "free_y") ## cols=vars(norm.method)
      # facet_wrap(~ labels, scales = 'free_y', ncol = ncol)


ggp

ggsave(paste0(fig.dir, '/', EndType, '_', norm.method, '_Combined.DeNovo.Sig.Clusters.', '_points.loess.jpg'), ggp, width = figw, height = figh, limitsize = F)
```


```{r, fig.show='hold',  fig.width = 9, fig.height = 12, eval=T}


gg <- ggplot(DT,
             aes(x=Time, y=read_count)) +
    #geom_line(aes(group=rep_gene, color=as.factor(best_label))) +
    geom_smooth(aes(group=rep_gene, color=as.factor(labels))) +
    #ggtitle(cluster_toplot) + 
    scale_color_manual(values = palette[]) +
    guides(color=guide_legend("de-novo cluster")) +
    scale_x_continuous(breaks = c(1,2,4,6,8,12,24,48)) +
    theme_ipsum() +
    theme(legend.position = 'right') +
    facet_nested(rows=vars(labels),
                 scales = "free_y"
                 #,rows=vars(as.factor(best_label))
                 ) 
gg


```


### De Novo - All clusters
```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}

ggp <- 
      ggplot(all.cluster.sum[],
             aes(Time, mean_read_count, color = as.factor(best_label))
                     #, add = 'loess'
                     ) + 
      geom_point() +
      geom_smooth() + 
      scale_color_manual(values = palette[]) +
      guides(color=guide_legend("de-novo cluster")) +
      #scale_y_continuous(labels = scales::percent_format()) +
      scale_x_continuous(breaks = c(1,2,4,6,8,12,24,48)) +
      theme_ipsum() +
      theme(plot.margin = unit(c(10,1,1,1), 'mm'),
            legend.position = 'bottom') +
       #theme(strip.background.y = element_rect(fill = alpha(strip.backgr, 0.4))) +
      # theme(strip.text.y = element_blank()) +
      #ggtitle(title) +
      facet_nested_wrap(~best_label, nrow = 2, scales = "free_y") ## cols=vars(norm.method)
      # facet_wrap(~ labels, scales = 'free_y', ncol = ncol)


ggp

ggsave(paste0(fig.dir, '/', EndType, '_', norm.method, '_Combined.DeNovo.All.Clusters.', '_points.loess.jpg'), ggp, width = figw, height = figh, limitsize = F)

```
```{r, fig.show='hold',  fig.width = 9, fig.height = 12, eval=T}


gg <- ggplot(DT,
             aes(x=Time, y=read_count)) +
    #geom_line(aes(group=rep_gene, color=as.factor(best_label))) +
    geom_smooth(aes(group=rep_gene, color=as.factor(best_label))) +
    #ggtitle(cluster_toplot) + 
    scale_color_manual(values = palette[]) +
    guides(color=guide_legend("de-novo cluster")) +
    scale_x_continuous(breaks = c(1,2,4,6,8,12,24,48)) +
    theme_ipsum() +
    theme(legend.position = 'right') +
    facet_nested(rows=vars(best_label),
                 scales = "free_y"
                 #,rows=vars(as.factor(best_label))
                 ) 
gg


```


### Literature clusters
```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}

ggp <- 
      ggplot(kin.class.sum,
             aes(Time, mean_read_count, color = Kinetic_class)
                     #, add = 'loess'
                     ) + 
      geom_point() +
      geom_smooth() + 
      scale_color_manual(values = palette[]) +
      guides(color=guide_legend("Kinetic Class")) +
      #scale_y_continuous(labels = scales::percent_format()) +
      scale_x_continuous(breaks = c(1,2,4,6,8,12,24,48)) +
      theme_ipsum() +
      theme(plot.margin = unit(c(10,1,1,1), 'mm'),
            legend.position = 'bottom') +
      # theme(strip.text.y = element_blank()) +
      #ggtitle(title) +
      # facet_nested(rows=vars(norm.method), cols=vars(labels), scales = "free_y") ## cols=vars(norm.method)
      facet_wrap(~ Kinetic_class, scales = 'free_y', ncol = ncol)


ggp

ggsave(paste0(fig.dir, '/', EndType, '_', norm.method, '_Combined.Literature.Clusters.', '_points.loess.jpg'), ggp, width = figw, height = figh, limitsize = F)

```
```{r, fig.show='hold',  fig.width = 9, fig.height = 12, eval=T}


gg <- ggplot(DT,
             aes(x=Time, y=read_count)) +
    #geom_line(aes(group=rep_gene, color=as.factor(best_label))) +
    geom_smooth(aes(group=rep_gene, color=as.factor(Kinetic_class))) +
    #ggtitle(cluster_toplot) + 
    scale_color_manual(values = palette[]) +
    guides(color=guide_legend("Kinetic Class")) +
    scale_x_continuous(breaks = c(1,2,4,6,8,12,24,48)) +
    theme_ipsum() +
    theme(legend.position = 'right') +
    facet_nested(rows=vars(Kinetic_class),
                 scales = "free_y"
                 #,rows=vars(as.factor(best_label))
                 ) 
gg


```

```{r}
## Export data
if (writetables) {
  fwrite(orf.sum.perc,          paste0(fig.dir, '/', norm.method, '_', EndType, '_counts.norm.tsv'), sep = '\t')
  fwrite(orf.perc.mean,         paste0(fig.dir, '/', norm.method, '_', EndType, '_abund.mean.tsv'), sep = '\t')
  
  fwrite(gene.kin.and.clusters, paste0(fig.dir, '/', norm.method, '_', EndType, '_Hclust.genes.and.kin.classes.tsv'), sep = '\t')
}
```


```{r bib, include=FALSE}
# KEEP THIS AT THE END OF THE DOCUMENT TO GENERATE A LOCAL bib FILE FOR PKGS USED
knitr::write_bib(sub("^package:", "", grep("package", search(), value=TRUE)), file='skeleton.bib')
```
