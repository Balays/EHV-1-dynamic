---
title: "EHV-1 Gene dynamics (TSS + TES) ~ Canonical Transcripts"
author: Bal√°zs Kakuk
output: 
  html_document:
    theme: cosmo
    toc: yes
    toc_float:
      collapsed: false
---

```{css, echo=FALSE}
    body .main-container {
      max-width: 90% !important;
      width: 90% !important;
    }
    body {
      max-width: 90% !important;
      margin-left: auto;
      margin-right: auto;
    }
```


```{r include=FALSE}
## hrbrthemes::ipsum:

knitr::opts_chunk$set(fig.retina=2, echo = FALSE, fig.align = 'center', message = F, warning = F)
```

```{r ipsum_setup, message=FALSE, warning=FALSE, cache=FALSE, echo=FALSE}
library(prettydoc)
library(hrbrthemes, quietly = T)
#library(GenomicFeatures, quietly = T)
library(DESeq2, quietly = T)
library(ggpubr, quietly = T)
#library(misc, quietly = T)
library(dplyr, quietly = T)
#library(tidyverse, quietly = T)
library(ggsci, quietly = T)
#library(Gviz, quietly = T)
library(dplyr, quietly = T)
library(tidyr)
library(scales)
#library(plyr)
library(moanin, quietly = T)
library(grid, quietly = T)
library(gridExtra, quietly = T) 
library(ggpubr, quietly = T)
library(data.table)
library(ggh4x)
library(knitr)
library(formattable)


###
source('_WF.part0.R')

#### Settings ####

## Main
#save.data <- 'PRV.rebase.RData'
EndType <- 'TSS.TES'

project_config  <- fread('project_config.txt')
outdir  <- project_config$outdir
res.dir <- outdir; try({ dir.create(res.dir) })
fig.dir <- paste0(res.dir, '/', EndType, '_abund'); # try({ dir.create(fig.dir) })## save plots to this directory

## Miscallenaous
palette <- pal_npg()(10)

writetables <- T



```


# Project info
Samples: dcDNA Seq  
pychopper: no  
mapping version: v6  
LoRTIA: yes (stranded only output)  


## Normalization: Viral read count

Count multiplier for DEG analysis: 10000x  
*This is to counter zeros*


# TSS dynamics 

## Those reads were counted only, where both *3-prime* AND *5-prime* adapters were "correct" (according to LoRTIA)



```{r, message=FALSE, warning=FALSE, cache=FALSE, echo=FALSE, eval=T}
#### Import counts

gene.sample_count.sp <- fread(paste0(res.dir, '/gene.sample.count.sp.tsv'), na.strings = '')


#### !!! Consider adapters!
adapters <- 'prime5'

source('Gene.counts.R')

#gene.sample_count    <- TR.ref.sum[,.(count=sum(read_count)), by=.(seqnames, strand, gene_cluster, gene, Kinetic_class, sample)]
#gene.sample_count.sp <- dcast(gene.sample_count, seqnames + strand + gene_cluster + gene + Kinetic_class ~ sample)
####

orf.sum <- gene.sample_count.sp

## Filter out multi-copied genes
orf.sum <- orf.sum[!gene %in% c('ORF64_2', 'ORF65_2', 'ORF66_2', 'ORF67_2'),]
orf.sum <- orf.sum[!gene_cluster %in% c('ORF64_2', 'ORF65_2', 'ORF66_2', 'ORF67_2'),]

## Format columns
#orf.sum <- orf.sum[,!c("seqnames", "gene_cluster"), with = FALSE]
#setnames(orf.sum, old=c('Kinetic_class'), new=c('ID'))
orf.sum[,ID := gene]

# Reordering columns to make new_column the first column
setcolorder(orf.sum, c("ID", setdiff(names(orf.sum), "ID")))

## Factorize
orf.sum$gene          <- factor(orf.sum$gene,  levels=ORFs)
orf.sum$ID            <- factor(orf.sum$ID,    levels=ORFs)
orf.sum$Kinetic_class <- factor(orf.sum$Kinetic_class, levels=c('IE', 'E', 'L'))

## Order
orf.sum        <- orf.sum[order(Kinetic_class, gene),]

##
orf.counts     <- as.data.frame(orf.sum)

orf.sum        <- merge(gather(orf.sum, sample, read_count, -c(1:6)), metafilt[,metacols], by='sample')
setDT(orf.sum)



#### Normalization method
norm.method <- 'viral_read.count'
multip      <- 10000

 if (norm.method == 'average_genome') {
  
  ## Average genome norm method
  norm_cov_summary <- fread(paste0(outdir, '/norm.cov.summary.tsv'), na.strings = '')
  normBase <- norm_cov_summary[,.(sample, average_coverage)]
  colnames(normBase)[2] <- 'norm_base'
  
  fig.dir <- paste0(fig.dir, '.norm_genome')

} else if (norm.method == 'viral_read.count') {
    
  ## Viral read count method
  # sum up all the ORF counts

  #normBase <- melt(gene.sample_count.sp, variable.name = 'sample', value.name = 'count')
  #normBase <- normBase[,.(norm_base = sum(count)), by=sample]
  normBase <- orf.sum[,.(norm_base = sum(read_count)), by=sample]
  
  fig.dir <- paste0(fig.dir, '.norm_LoRTIA')
  
} else if (norm.method == 'total_read.count') {
  ## For total read count method

  # This is not the LoRTIA-processed read counts, so each read is counted twice because they are from dcDNA that contains both orientations. 
  # But since this is true for both the virus and the host, this will cause each ORF to be estimated down approx 2-fold but in an unbiased way.

  normBase <- fread('../fastq_read_counts.tsv')
  #normBase[ , sample := gsub('.fastq', '', file)]
  normBase[ , norm_base := read_count]
  normBase <- normBase[,.(sample, norm_base)]
  
  fig.dir <- paste0(fig.dir, '.norm_total')
  
} else if (norm.method == 'host_read.count') {
  ## For total HOST read count method

  # This is not the LoRTIA-processed read counts, so each read is counted twice because they are from dcDNA that contains both orientations. 
  # But since this is true for both the virus and the host, this will cause each ORF to be estimated down approx 2-fold but in an unbiased way.
  # Currently this is the unmapped read count!

  viral_reads <- melt(gene.sample_count.sp, variable.name = 'sample', value.name = 'count')
  viral_reads <- viral_reads[,.(viral_read_count = sum(count)), by=sample]
  
  total_reads <- fread('../fastq_read_counts.tsv')
  
  normBase    <- merge(total_reads, viral_reads, by='sample')
  normBase[,norm_base := read_count - viral_read_count]
  
  normBase <- normBase[,.(sample, norm_base)]
   
  fig.dir <- paste0(fig.dir, '.norm_host')
  
} else if (norm.method == 'WO') {
  
  ## NO normalization of counts

  normBase <- data.table(sample = metafilt$sample, norm_base = 1)
  
  fig.dir <- paste0(fig.dir, '.norm_Without')
  
}

try({ dir.create(fig.dir) })

##
normBase <- normBase[order(normBase$sample, colnames(orf.counts[-c(1:6)])), ]
stopifnot(all(normBase$sample == colnames(orf.counts[-c(1:6)]) ))

orf.perc <- merge(normBase, orf.sum, by='sample')
orf.perc[,read_count := read_count / norm_base]


#### TO-DO: 

## 1.) find which replicate is the farthest from the mean in each gene for each group -> done
## 2.) Carry out the moanin analyis using the current normalization 
## 3.) Check the overlap of Literature-based kinetic classes and de-novo clusters
```


```{r}
### Filtering of very-low coverage samples
samples_to_filt <- NULL #c('C6_2h_3', 'PC-12_8h_3')

if (!is.null(samples_to_filt)) {
  
  orf.perc <- orf.perc[!orf.perc$sample %in% samples_to_filt, ]
  metafilt <- metafilt[!metafilt$sample %in% samples_to_filt, ]
  
  message(paste(samples_to_filt, ' was filtered out!', collapse = '\n') )

}
```


## Statistics of counts {.tabset}
```{r, message=FALSE, warning=FALSE, cache=FALSE, echo=FALSE}

orf.sum.perc <- orf.perc

if (EndType == 'TES') {
  
  #### Keep those where the TES was correct, regardless of TSS
  message('Keeping those where the TES was correct, regardless of TSS !')
  orf.sum.perc[,gene   := gene_cluster]
  orf.sum.perc <- orf.sum.perc[!is.na(gene), ]
  
} else if (EndType == 'TSS') {
  
  #### Keep those where the TSS was correct, regardless of TES
  message('Keeping those where the TSS was correct, regardless of TES !')
  orf.sum.perc[,gene_cluster   := gene]
  orf.sum.perc <- orf.sum.perc[!is.na(gene), ]
  
} else if (EndType == 'TSS.TES') {
  
  #### Keep those where noth the TSS and TES were correct
  message('Keeping those where noth the TSS and TES were correct !')
  orf.sum.perc[,gene_cluster   := gene]
  orf.sum.perc <- orf.sum.perc[!is.na(gene), ]
}

gene_kin.class <- na.omit(unique(orf.sum.perc[,.(gene, Kinetic_class)]))
gene_kin.class[,Kinetic_class := paste(Kinetic_class, collapse = '/'), by=.(gene)]
gene_kin.class <- unique(gene_kin.class[,.(gene, Kinetic_class)])

orf.sum.perc[,Kinetic_class := NULL]

#### Summarize the counts

## summarise counts on gene cluster
orf.sum.perc <- orf.sum.perc[,.(read_count=sum(read_count)), by=.(seqnames, strand, gene, norm_base, sample, group, hpi, Time, cell_line)]
orf.sum.perc <- merge(orf.sum.perc, gene_kin.class, by='gene', all=T)
orf.sum.perc[is.na(Kinetic_class), Kinetic_class := 'unknown']
orf.sum.perc[,Kinetic_class := factor(Kinetic_class, levels = c('IE', 'IE/E', 'E', 'IE/E/L', 'E/L', 'L', 'unknown'))]

### Statistics of gene cluster counts accross samples

## normalized counts
orf.perc.mean <- 
  orf.sum.perc[,.(mean=mean(read_count), sd=sd(read_count), varcoeff=sd(read_count) / mean(read_count)), 
               by=.(gene, Kinetic_class, hpi, Time, cell_line)]


#### merge back summary with counts
orf.sum.perc <- merge(orf.sum.perc, orf.perc.mean, by=c('gene', 'Kinetic_class', 'hpi', 'Time', 'cell_line'))


```

### Difference from mean
```{r, fig.width = 9, fig.height = 6, eval=T}

#### Find which replicate is the farthest from the mean in each gene for each group

# find distance from mean
orf.sum.perc[ , dist_from_mean := abs(mean - read_count)]

##
orf.sum.perc[ , farthest_from_mean := fifelse(dist_from_mean == max(dist_from_mean), T, F), by=.(group, gene)]
# NA, if all is true in each group beacuse then the distance is the same which means probably that the gene has zero counts in that group
orf.sum.perc[ , farthest_from_mean := if(sum(dist_from_mean) == 0) NA, by=.(group, gene)]
orf.sum.perc[ , farthest_rep       := fifelse(!is.na(farthest_from_mean) & farthest_from_mean == T, gsub('.*_', '', sample), 'NA'), by=.(sample, gene)]

plot.data  <- orf.sum.perc[!is.na(farthest_rep), .N, by=.(farthest_rep, hpi, Time, cell_line, group)][order(group)]

ggplot(
  plot.data,
  aes(x=hpi, y=N, fill=farthest_rep)) +
  geom_col(position = 'dodge2') +
  scale_fill_d3() +
  theme_bw() # + facet_grid(rows=vars(hpi))

```


### Varcoeff
```{r, fig.width = 20, fig.height = 8}

ggplot(
  orf.sum.perc[],
  aes(x=gene, y=varcoeff, fill=hpi)) +
  geom_col(position = 'dodge2') +
  scale_fill_d3() +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90)) +
  facet_grid(rows=vars(cell_line))


```

## Moanin - Differential timecourse expression analysis {.tabset}

```{r}
## metadata
sampdat <- metafilt

sampdat$sample     <- gsub('-', '_', metafilt$sample    )
sampdat$group      <- paste(metafilt$cell_line, metafilt$hpi, sep='_')
sampdat$cell_line  <- gsub('-', '_', metafilt$cell_line)
sampdat <- data.frame(sampdat [,     ],  row.names = sampdat$sample)
sampdat <- sampdat[order(sampdat$cell_line, sampdat$Time),]

## count data
countData <- as.data.frame(dcast(orf.sum.perc, gene ~ sample, value.var = 'read_count'))
colnames(countData) <- gsub('-', '_', colnames(countData))
countData <- countData[,c('gene', sampdat$sample)]
countData <- as.matrix(data.frame(countData[,-1], row.names = countData$gene))

## multiplication -->> need to test whether this gives difference!!

countData <- countData * multip

countData <- apply(countData, 2, round)

## duplicate data beause monain expects at least two groups
countData_dup <- countData
sampdat_dup   <- sampdat
sampdat_dup$cell_line <- "RK_13_Dup"

colnames(countData_dup) <- paste0(colnames(countData_dup), '_dup')
rownames(sampdat_dup)   <- paste0(rownames(sampdat_dup),   '_dup')

countData     <- cbind(countData_dup, countData)
sampdat       <- rbind(sampdat_dup,   sampdat)


## colors
group_colors = c(
     "PK_15"=colordf$npg[1],
     "C6"=colordf$npg[2],
     "PC_12"=colordf$npg[3],
     "RK_13"=colordf$npg[4],
     "RK13_Dup"=colordf$npg[5]
     )

time_colors <- viridisLite::magma(length(unique(sampdat$Time))) # 
names(time_colors) <- unique(sampdat$Time)

# Combine all color schemes into one named lists.
ann_colors = list(
     Time=time_colors,
     cell_line=group_colors
     )


# Prepare Data
dds <- DESeqDataSetFromMatrix(countData = countData, 
                              colData   = sampdat[,c('cell_line', 'Time')], 
                              design    = ~ cell_line + Time)

# Differential Expression Analysis
moanin_model <- create_moanin_model(data=dds, 
                                    #data=otutab, #), 
                                    #meta=sampdat, # metam, #
                                    group_variable_name = "cell_line",
                                    time_variable_name  = "Time",
                                    log_transform = F
                                    #degrees_of_freedom=6
                                    )
moanin_model@NAMES <- rownames(countData)

#contrasts <- create_timepoints_contrasts(moanin_model, "C6", "PK_15")
timecourse_contrasts <- c("RK_13-RK_13_Dup")
```


```{r, eval=F}
# Differential Time-course expression analysis
timecourse_contrasts <- c("RK_13-RK_13_Dup")

DE_results <- DE_timecourse(moanin_model, timecourse_contrasts, center=F)

pvalues <- DE_results[, grepl("pval", colnames(DE_results))]
qvalues <- DE_results[, grepl("qval", colnames(DE_results))]


## Gather results
DE_results <- data.frame(ORF=rownames(DE_results), DE_results) %>%
  gather(contrast, value, -1 )
DE_results$stat <- gsub('.*_', '', DE_results$contrast)

DE_results <- DE_results %>%
  rowwise() %>%
  mutate(contrast = str_replace(contrast, paste0('_', stat), ''))


## DEGs
DE_results$sig <- F
DE_results$sig[DE_results$stat == 'pval' & DE_results$value <= 0.05] <- T


DEGs <- unique(DE_results$ORF[DE_results$sig == T])



```

### Statistics for every gene
```{r, fig.width=14, fig.height=13, eval=F}

ggplot(DE_results, #[DE_results$ORF %in% DEGs, ], 
       aes(ORF, value, fill=contrast)) +
  geom_col(position = 'dodge2') +
  coord_flip() +
  theme_ipsum_rc() +
  facet_nested(cols=vars(stat))
```

### DEGs
```{r, fig.width=14, fig.height=13, eval=F}
try({
ggplot(DE_results[DE_results$ORF %in% DEGs, ], 
       aes(ORF, value, fill=contrast)) +
  geom_col(position = 'dodge2') +
  coord_flip() +
  theme_ipsum_rc() +
  facet_nested(cols=vars(stat))
})

```


### (log2) Fold-Changes of every gene
```{r, fig.width=10, fig.height=13}
log_fold_change_timepoints <- 
  estimate_log_fold_change(moanin_model, 
                           timecourse_contrasts,
                           method="timely")

log_fold_change_timecourse <- 
  estimate_log_fold_change(moanin_model,
                           timecourse_contrasts, 
                           method="timecourse")

plot_data <- data.frame(
  ORF=rownames(log_fold_change_timecourse), 
  log_fold_change_timecourse) %>% 
  gather(contrast, l2FC, -1)


ggplot(plot_data, 
       aes(ORF, l2FC, fill=contrast)) +
  geom_col(position = 'dodge2') +
  coord_flip() +
  theme_ipsum_rc() # + facet_nested(cols=vars(stat))
```

### (log2) Fold-Changes of DEGs
```{r, fig.width=10, fig.height=13, eval=F}
try({
ggplot(plot_data[plot_data$ORF %in% DEGs, ], 
       aes(ORF, l2FC, fill=contrast)) +
  geom_col(position = 'dodge2') +
  coord_flip() +
  theme_ipsum_rc() # + facet_nested(cols=vars(stat))
})
```

### Splines of each gene
```{r, fig.width=24, fig.height=30}

#top_DE_genes_pval = names(sort(pvalue)[1:10])
plot_splines_data(moanin_model, #subset_data=top_DE_genes_pval, 
    colors=ann_colors$cell_line, smooth=TRUE,
    mar=c(1.5,2.5,2,0.1))

```

### Splines of DEGs
```{r, fig.width=16, fig.height=20, eval=F}
try({
#top_DE_genes_pval = names(sort(pvalue)[1:10])
plot_splines_data(moanin_model, subset_data=DEGs, 
    colors=ann_colors$cell_line, 
    simpleY = F, yaxis=T,
    smooth=TRUE,
    mar=c(1.5,2.5,2,0.1))
})
```

## Moanin - Clustering of genes into de novo kinetic classes {.tabset}
```{r, eval=F}
log_fold_change_max <- estimate_log_fold_change(moanin_model, timecourse_contrasts, method="max")
log_fold_change_min <- estimate_log_fold_change(moanin_model, timecourse_contrasts, method="min")

# Then rank by fisher's p-value and take max the number of genes of interest
# Filter out q-values for the pvalues table
fishers_pval <- pvalues_fisher_method(pvalues)
qvalues      <- apply(pvalues, 2, p.adjust)
fishers_qval <- p.adjust(fishers_pval)

genes_to_keep = row.names(
  log_fold_change_max[
    (rowSums(log_fold_change_max > 2) >= 0 | rowSums(log_fold_change_min <= -2) > 0) #&
    #(fishers_qval < 0.05 & !is.na(fishers_qval))
    ,])

# Keep the data corresponding to the genes of interest in another variable.
# by subsetting the `moanin_model`, which contains the data.
de_moanin_model <- moanin_model[genes_to_keep, ]

genes_to_keep
```

### Filter the model to RK-13 only
```{r}

RK13_moanin_model <- moanin_model[,moanin_model$cell_line == 'RK_13']

```


### Number of clusters
```{r, fig.width=9, fig.height=7}
all_possible_n_clusters = c(2:15)
all_clustering = list()
wss_values = list()

i = 1
for(n_cluster in all_possible_n_clusters){
    clustering_results = splines_kmeans(RK13_moanin_model,
    n_clusters=n_cluster, random_seed=42,
    n_init=10)
    wss_values[i] = sum(clustering_results$WCSS_per_cluster)
    all_clustering[[i]] = clustering_results$clusters
    i = i + 1
}

plot(all_possible_n_clusters, wss_values, 
      type="b", pch=19, frame=FALSE,
      xlab="Number of clusters K",
      ylab="Total within-clusters sum of squares")
```
 Plot of within cluster sum of squares (WCSS) as a function of k.

*Here 5 clusters were chosen*


### Clustering
```{r}
kmeans_clusters <- splines_kmeans(RK13_moanin_model, n_clusters=5,
     random_seed=42,
     n_init=20)
```


```{r, fig.width=12, fig.height=9}
try({
plot_splines_data(RK13_moanin_model,
    data=kmeans_clusters$centroids, 
    colors=ann_colors$cell_line,
    smooth=TRUE)
})
```

### Genes in the clusters
```{r}
cluster_of_interest = 3
cluster2Genes = names(
     kmeans_clusters$clusters[kmeans_clusters$clusters==cluster_of_interest])
```


```{r, fig.width=12, fig.height=9}
try({
plot_splines_data(RK13_moanin_model,  
    centroid=kmeans_clusters$centroids[cluster_of_interest,], 
    colors=ann_colors$cell_line, smooth=TRUE, simpleY =TRUE,
    subset_data=cluster2Genes[],
    mar=c(1.5,2.5,2,0.1))
})
```

### Assigning genes to clusters
```{r}
scores_and_labels <- splines_kmeans_score_and_label(
     RK13_moanin_model, kmeans_clusters)

labels <- scores_and_labels$labels

# Let's keep only the list of genes that have a label.
labels <- unlist(labels[!is.na(labels)])

# Get the best score and best label for all of the genes
# This time without filtering labels
# We can give the previous calculated scores to `previous_scores` to save time
unfiltered_scores <- splines_kmeans_score_and_label(
     RK13_moanin_model, kmeans_clusters,
     proportion_genes_to_label=1,
     #rescale_separately=T,
     previous_scores=scores_and_labels$scores)

scores.dt  <- melt(unfiltered_scores$scores)
colnames(scores.dt) <- c('ORF', 'label', 'score')

best_label <- unfiltered_scores$labels
cluster_labels <- merge(as.data.frame(labels), as.data.frame(best_label), by=0, all=T) 
colnames(cluster_labels)[1] <- 'ORF'

all.scores.dt      <- merge(cluster_labels, scores.dt, by.x=c('ORF', 'best_label'), by.y=c('ORF', 'label'), all=T)
cluster_labels     <- merge(cluster_labels, scores.dt, by.x=c('ORF', 'best_label'), by.y=c('ORF', 'label'))

### WRITE OUT DEG analyis and clustering RESULTS

DE_cluster_results <- cluster_labels
#DE_cluster_results <- merge(DE_results, cluster_labels, by='ORF')
#stopifnot(nrow(DE_cluster_results) == nrow(DE_results))


```


```{r, eval=FALSE}
par(mfrow=c(3, 3))
n_clusters <- dim(kmeans_clusters$centroids)[1]
for(cluster_id in 1:n_clusters){
    hist(cluster_labels[best_label==cluster_id, 'score'],
     #breaks=(1:50/50), 
     xlim=c(0, 1),
     col="black", main=paste("C", cluster_id, sep=""),
     xlab="score", ylab="Num. genes")
    abline(v=scores_and_labels$score_cutoff, col="red", lwd=3, lty=2)
}


```



## ORF kinetics, according to literature-based kinetic classes {.tabset}


```{r}
### ORFs in samples calculated from TRS-B transcripts with and without leaders

max_ncol   <- 9
row_multip <- 6
col_multip <- 4
my_pal <- pal_d3()(10)


plotfun <- function(DT, 
                    geom1 = geom_pointrange(aes(ymin = mean-sd, ymax = mean+sd), colour = 'black'),
                    geom2 = geom_line(aes(x=Time, y=mean), color=kincolor),
                    geom3 = geom_point(aes(x=Time, y = mean), fill=kincolor, shape = 21, size = 3, colour = 'black'),
                    ncol = 10, title = NULL, #"Normalized ORF counts", 
                    strip.backgr = pal_d3()(10)[2],
                    kincolor=NULL) {
  
  if (nrow(DT) == 0) { 
    ggp <- NULL } else {   # try({ 
      
    # 
    gene_N <- length(unique(DT[,gene]))
    # class_freq <- DT[best_label == 5][,.N,by=class_col]
    
    #colid <- c('gene', class_col)
    #class_freq <- unique(DT[best_label == 5, ..colid])
    
    
    #  min(class_freq)
     # =='adaptive') {}
        
    ggp <- 
      ggplot(DT[
                                #  orf.perc.mean$hpi    != 'dRNA' 
                                #& orf.perc.mean$strand == '+'
                                , ], 
                     aes(Time, mean, color = 'cell_line')
                     #, add = 'loess'
                     ) + 
      geom1 +
      geom2 + 
      geom3 +
      scale_color_manual(values = palette) +
      scale_y_continuous(labels = scales::percent_format(), name = 'Mean abundance %') +
      scale_x_continuous(name = 'Hours past infection') +
      theme_ipsum() +
      theme(plot.margin = unit(c(1,1,1,1), 'mm')) +
      facet_wrap(~ gene, scales = 'free_y', ncol = ncol) +
      theme(strip.background = element_rect(fill = alpha(strip.backgr, 0.4))
            )
      # + ggtitle(title)
  
  if (gene_N < ncol) { 
    if(gene_N == 1) { gene_N <- 1.5}
    ggp <- cowplot::plot_grid(ggp, NULL, rel_widths = c(gene_N, ncol - gene_N ), nrow=1)
  }
  
  }   # })
  
  return(ggp)

}


## Barplot 
plotfun_all <- function(DT, 
                        geom_1 = geom_col(aes(x=gene, y=mean, fill=Kinetic_class), alpha=0.7, color='black'),
                        geom_2 = geom_errorbar(aes(x=gene, ymin = mean-sd, ymax=mean+sd)),
                        coord_c=coord_cartesian(ylim = c(0, 0.6)),
                        scale  = NULL, #scale_y_continuous(),
                        scfill = scale_fill_manual(values = palette),
                        cflip  = coord_flip(),
                        theme_g = theme_bw(),
                        facet   = facet_nested(rows=vars(Kinetic_class), cols = vars(hpi), scales = 'free_y'),
                        strip.backgr = pal_d3()(10)[2],
                        ncol = 10,
                        ...) {
  
  gene_N <- length(unique(DT[,gene]))
  
  ggp <- 
    ggplot(DT) +
    geom_1   +
    geom_2   +
    coord_c  +
    scale    +
    scfill   +
    cflip    +
    theme_g  +
    theme(strip.background = element_rect(fill = alpha(strip.backgr, 0.4)), ...) +
    facet
  
  if (gene_N < ncol) { 
    if(gene_N == 1) { gene_N <- 1.5}
    ggp <- cowplot::plot_grid(ggp, NULL, rel_widths = c(gene_N, ncol - gene_N ), nrow=1)
  }
  
  return(ggp)

}

#DT=orf.perc.mean
```



```{r}
# Kinetic class frequency

kin_classes      <- unique(orf.perc.mean[,.(gene, Kinetic_class)])
all.class.freq   <- data.table(kin_classes)[,.N, by=.(Kinetic_class) ][order(Kinetic_class)]

ncol     <- ifelse(max(all.class.freq$N) < max_ncol, max(all.class.freq$N), max_ncol)
relh     <- ceiling(all.class.freq$N / ncol)  #c(6,1,1,1,2)

```


```{r}
## Barplots

mapfun <- function(i, DT, all.class.freq, palette = my_pal, ...) {
  kin_class <- all.class.freq[i, Kinetic_class]
  strip.background <- palette[i]
  plotfun_all(DT[Kinetic_class == kin_class],  strip.backgr = strip.background, ...)
}

figh     <- length(unique(orf.perc.mean[,gene])) * 0.35
figw     <- figh

```


### Barplot of mean and SD
```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}
ggp <- plotfun_all(orf.perc.mean)

ggsave(paste0(fig.dir, '/', EndType, '_', norm.method,  '_Literature.Clusters', '_barplot.jpg'), ggp, width = figw, height = figh, limitsize = F)

ggp
```


```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}
ggp <- purrr::map(seq_along(relh), mapfun, orf.perc.mean, all.class.freq, ncol=ncol, legend.position='none')

ggp <- cowplot::plot_grid(plotlist = ggp, ncol = 1, rel_heights = relh, align = 'vh', axis=c('tblr'))

ggsave(paste0(fig.dir, '/', EndType, '_', norm.method,  '_Literature.Clusters', '_barplot2.jpg'), ggp, width = figw, height = figh, limitsize = F)

ggp

```



```{r}
## Scatter and line plots

mapfun <- function(i, DT, all.class.freq, palette = my_pal, ...) {
  kin_class <- all.class.freq[i, Kinetic_class]
  strip.background <- palette[i]
  plotfun(DT[Kinetic_class == kin_class],  
          strip.backgr = strip.background, 
          kincolor=strip.background,
          ...)
}


figw     <- ncol * col_multip
figh     <- nrow(all.class.freq) * row_multip

```


### Figure 5 REVIEW - Mean and SD with linear connection
```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}

ggp <- purrr::map(seq_along(relh), mapfun, orf.perc.mean, all.class.freq, ncol=ncol)

ggp <- cowplot::plot_grid(plotlist = ggp, ncol = 1, rel_heights = relh, align = 'v', axis=c('tblr'))


ggsave('Figures/Figure 4_REVIEW.jpg',  ggp, width = figw*0.8, height = figh, limitsize = F)

ggp
```


### Mean and SD with loess function
```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}
ggp <- purrr::map(seq_along(relh), mapfun, orf.perc.mean, all.class.freq, ncol=ncol)

ggp <- cowplot::plot_grid(plotlist = ggp, ncol = 1, rel_heights = relh, align = 'v', axis=c('tblr'))

ggsave(paste0(fig.dir, '/', EndType, '_', norm.method,  '_Literature.Clusters', '_mean.sd.loess.jpg'), ggp, width = figw, height = figh, limitsize = F)

ggp
```


### Mean and SD with linear connection - Figure 4
```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}

ggp <- purrr::map(seq_along(relh), mapfun, orf.perc.mean, all.class.freq, ncol=ncol, 
                  geom1 = geom_pointrange(aes(ymin = mean-sd, ymax = mean+sd, colour = cell_line)),
                  geom2 = geom_line(aes(x=Time, y=mean, color=cell_line)))

ggp <- cowplot::plot_grid(plotlist = ggp, ncol = 1, rel_heights = relh, align = 'v', axis=c('tblr'))


ggsave(paste0(fig.dir, '/', EndType, '_', norm.method, '_Literature.Clusters', '_mean.sd.linear.jpg'), ggp, width = figw, height = figh, limitsize = F)

ggsave('./Figures/Figure 4.jpg',       ggp, width = figw*0.8, height = figh,   limitsize = F)
ggsave('./Figures/Figure 4.small.jpg', ggp, width = figw*0.6, height = figh,   limitsize = F)

ggp
```

### Each replicate with loess
```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}

ggp <- purrr::map(seq_along(relh), mapfun, orf.sum.perc, all.class.freq, ncol=ncol, 
                  geom1 = geom_point( aes(x=Time, y=read_count, color=cell_line)),
                  geom2 = geom_smooth(aes(x=Time, y=read_count, color=cell_line)) )

ggp <- cowplot::plot_grid(plotlist = ggp, ncol = 1, rel_heights = relh, align = 'v', axis=c('tblr'))


ggsave(paste0(fig.dir, '/', EndType, '_', norm.method, '_Literature.Clusters', '_replicates.loess.jpg'), ggp, width = figw, height = figh, limitsize = F)

ggp
```


## ORF kinetics, according to de-novo kinetic classes {.tabset}


```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}

my_pal <- pal_jco()(10)[c(2,3,4,5,7)]

#DE_cluster_results <- fread(paste0(outdir, '/', 'moanin_DE_results.tsv'))
setDT(DE_cluster_results)
DEGs               <- unique(DE_cluster_results$ORF[DE_cluster_results$sig == T])

## Add cluster info
orf.perc.mean <- merge(orf.perc.mean, unique(DE_cluster_results[,.(ORF, best_label, labels)]), by.x='gene', by.y='ORF', all.x=T)
orf.sum.perc  <- merge(orf.sum.perc,  unique(DE_cluster_results[,.(ORF, best_label, labels)]), by.x='gene', by.y='ORF', all.x=T)

# LAbels frequency
all.label.freq    <- data.table(cluster_labels)[,.N, by=.(best_label) ][order(best_label)]
sig.label.freq    <- na.omit(data.table(cluster_labels)[,.N, by=.(labels) ][order(labels)])


```


### All ORFs - Mean and SD with linear connection


```{r}
## Scatter and line plots
ncol     <- ifelse(max(all.label.freq$N) < max_ncol, max(all.label.freq$N), max_ncol)
relh     <- ceiling(all.label.freq$N / ncol)  #c(6,1,1,1,2)

mapfun <- function(i, DT, label.freq, palette = my_pal, ...) {
  kin_class <- label.freq[i, best_label]
  strip.background <- palette[i]
  plotfun(DT[best_label == kin_class],  
          strip.backgr = strip.background, 
          kincolor=strip.background,
          ...)
}


figw     <- ncol * col_multip
figh     <- nrow(all.label.freq) * row_multip

```


### Figure 5 REVIEW - Mean and SD with linear connection
```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}

ggp <- purrr::map(seq_along(relh), mapfun, orf.perc.mean, all.label.freq, ncol=ncol)

ggp <- cowplot::plot_grid(plotlist = ggp, ncol = 1, rel_heights = relh, align = 'v', axis=c('tblr'))


ggsave('Figures/Figure 5_REVIEW.jpg',  ggp, width = figw*0.8, height = figh, limitsize = F)

ggp
```




### Clustered ORFs only - Mean and SD with linear connection

```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}
#
#IE.ratio <- 0.43
ncol     <- ifelse(max(sig.label.freq$N) < max_ncol, max(sig.label.freq$N), max_ncol)
relh     <- ceiling(sig.label.freq$N / ncol)  #c(6,1,1,1,2)
figw     <- ncol * col_multip
figh     <- nrow(sig.label.freq) * row_multip


mapfun <- function(i, DT, label.freq, palette = my_pal, ...) {
  label <- label.freq[i, labels]
  strip.background <- palette[i]
  plotfun(DT[best_label == label & !is.na(labels)],  strip.backgr = strip.background, ...)
}


ggp <- purrr::map(seq_along(relh), mapfun, orf.perc.mean, sig.label.freq, ncol=ncol, 
                  geom1 = geom_pointrange(aes(ymin = mean-sd, ymax = mean+sd, colour = cell_line)),
                  geom2 = geom_line(aes(x=Time, y=mean, color=cell_line)))

ggp <- cowplot::plot_grid(plotlist = ggp, ncol = 1, rel_heights = relh, align = 'v', axis=c('tblr'))



ggsave(paste0(fig.dir, '/',  EndType, '_', norm.method, '_DeNovo.Sig.Clusters', '_mean.sd.linear.jpg'), ggp, width = figw, height = figh, limitsize = F)
```

```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}
ggp
```




## Compare literature and de novo kinetic classes

*NA shows the number of genes where the clustering did not yield an unambiguous result.*
  
```{r, fig.show='hold',  fig.width = 15, fig.height = 6, eval=T}
setDT(orf.perc.mean)
class.dt <- unique(orf.perc.mean[, .(gene, Kinetic_class, best_label, labels)])
class.dt <- class.dt[, .N, by=.(Kinetic_class, best_label, labels)]

#cluster_labels

ggplot(class.dt,
       aes(x=Kinetic_class, y=N, fill=as.factor(best_label))) +
  geom_col(position = 'dodge') +
  scale_color_manual(values = palette) +
  #scale_y_continuous(labels = scales::percent_format()) +
  theme_ipsum() +
  facet_wrap(~labels, nrow = 1)


ggplot(class.dt,
       aes(x=as.factor(best_label), y=N, fill=Kinetic_class)) +
  geom_col(position = 'stack') +
  scale_color_manual(values = palette) +
  #scale_y_continuous(labels = scales::percent_format()) +
  theme_ipsum() +
  facet_nested_wrap(~labels, nrow = 1)


```

## Combine Kinetic classes

```{r}
### Summarise based on literature kinetic class
kin.class.sum  <- orf.sum.perc[,.(sum_read_count=sum(read_count), mean_read_count=mean(read_count), sd_read_count=sd(read_count)), 
                              by=.(Kinetic_class, hpi, Time, cell_line, seqnames, norm_base, sample, group)]


### Summarise based on SIGNIFICANT de-novo kinetic cluster
sig.cluster.sum <- orf.sum.perc[,.(sum_read_count=sum(read_count), mean_read_count=mean(read_count), sd_read_count=sd(read_count)), 
                              by=.(labels, hpi, Time, cell_line, seqnames, norm_base, sample, group)]


### Summarise based on all de-novo kinetic cluster
all.cluster.sum <- orf.sum.perc[,.(sum_read_count=sum(read_count), mean_read_count=mean(read_count), sd_read_count=sd(read_count)), 
                              by=.(best_label, hpi, Time, cell_line, seqnames, norm_base, sample, group)]


```

```{r}
figw <- 13
figh <- 6
ncol <- 10
```



### De Novo - Significant
```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}

ggp <- 
      ggplot(sig.cluster.sum,
             aes(Time, mean_read_count, color = cell_line)
                     #, add = 'loess'
                     ) + 
      geom_point() +
      geom_smooth() + 
      scale_color_manual(values = palette[]) +
      #scale_y_continuous(labels = scales::percent_format()) +
      theme_ipsum() +
      theme(plot.margin = unit(c(10,1,1,1), 'mm')) +
      #theme(strip.background.y = element_rect(fill = alpha(strip.backgr, 0.4))) +
      # theme(strip.text.y = element_blank()) +
      #ggtitle(title) +
      # facet_nested(rows=vars(norm.method), cols=vars(labels), scales = "free_y") ## cols=vars(norm.method)
      facet_wrap(~ labels, scales = 'free_y', ncol = ncol)


ggp

ggsave(paste0(fig.dir, '/', EndType, '_', norm.method, '_Combined.DeNovo.Sig.Clusters.', '_points.loess.jpg'), ggp, width = figw, height = figh, limitsize = F)

```


### De Novo - All clusters
```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}

ggp <- 
      ggplot(all.cluster.sum,
             aes(Time, mean_read_count, color = cell_line)
                     #, add = 'loess'
                     ) + 
      geom_point() +
      geom_smooth() + 
      scale_color_manual(values = palette[]) +
      #scale_y_continuous(labels = scales::percent_format()) +
      theme_ipsum() +
      theme(plot.margin = unit(c(10,1,1,1), 'mm')) +
      #theme(strip.background.y = element_rect(fill = alpha(strip.backgr, 0.4))) +
      # theme(strip.text.y = element_blank()) +
      #ggtitle(title) +
      # facet_nested(rows=vars(norm.method), cols=vars(labels), scales = "free_y") ## cols=vars(norm.method)
      facet_wrap(~ best_label, scales = 'free_y', ncol = ncol)


ggp

ggsave(paste0(fig.dir, '/', EndType, '_', norm.method, '_Combined.DeNovo.All.Clusters.', '_points.loess.jpg'), ggp, width = figw, height = figh, limitsize = F)

```


### Literature clusters
```{r, fig.show='hold',  fig.width = figw, fig.height = figh, eval=T}

ggp <- 
      ggplot(kin.class.sum,
             aes(Time, mean_read_count, color = cell_line)
                     #, add = 'loess'
                     ) + 
      geom_point() +
      geom_smooth() + 
      scale_color_manual(values = palette[]) +
      #scale_y_continuous(labels = scales::percent_format()) +
      theme_ipsum() +
      theme(plot.margin = unit(c(10,1,1,1), 'mm')) +
      #theme(strip.background.y = element_rect(fill = alpha(strip.backgr, 0.4))) +
      # theme(strip.text.y = element_blank()) +
      #ggtitle(title) +
      # facet_nested(rows=vars(norm.method), cols=vars(labels), scales = "free_y") ## cols=vars(norm.method)
      facet_wrap(~ Kinetic_class, scales = 'free_y', ncol = ncol)


ggp

ggsave(paste0(fig.dir, '/', EndType, '_', norm.method, '_Combined.Literature.Clusters.', '_points.loess.jpg'), ggp, width = figw, height = figh, limitsize = F)

```


```{r}
## Export data
if (writetables) {
  fwrite(orf.sum.perc,       paste0(fig.dir, '/', norm.method, '_', EndType, '_counts.norm.tsv'), sep = '\t')
  fwrite(orf.perc.mean,      paste0(fig.dir, '/', norm.method, '_', EndType, '_abund.mean.tsv'), sep = '\t')
  fwrite(DE_cluster_results, paste0(fig.dir, '/', norm.method, '_', EndType, '_moanin_DE_results.tsv'), sep = '\t')

}
```


```{r bib, include=FALSE}
# KEEP THIS AT THE END OF THE DOCUMENT TO GENERATE A LOCAL bib FILE FOR PKGS USED
knitr::write_bib(sub("^package:", "", grep("package", search(), value=TRUE)), file='skeleton.bib')
```
